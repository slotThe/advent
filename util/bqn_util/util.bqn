# ğ•¨ Split ğ•© splits the vector ğ•© according to the separator ğ•¨.
#
#     ' ' Split "  A string   containing a   sentence.   "
# âŸ¨ "A" "string" "containing" "a" "sentence." âŸ©
Split â‡ (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢

# Like split, but works for higher-dimensional things.
#
#     "z" SplitF âŸ¨"a", "b", "z", "c", "z", "d", "e", "f"âŸ©
# âŸ¨ âŸ¨ "a" "b" âŸ© âŸ¨ "c" âŸ© âŸ¨ "d" "e" "f" âŸ© âŸ©
SplitF â‡ { ((Â¯1+âŠ¢Ã—Â·+`Â»âŠ¸<)Â¬ğ•¨âŠ¸â‰¡Â¨ğ•©)âŠ”ğ•© }

# F _Fix y computes the fixed point of F starting at y (avoiding stack
# overflow).
_Fix â‡ { ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½_ğ•£âˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•© }

# Slurp out all integers in a string.
#     Ints "(12,-246,478|rstr)-45"
# âŸ¨ 12 Â¯246 478 Â¯45 âŸ©
Ints â‡ { â€¢ParseFloatÂ¨((Â¯1+âŠ¢Ã—Â·+`Â»âŠ¸<)ğ•©âˆŠ'-'âˆ¾'0'+â†•10)âŠ”ğ•© }

# Indices of all 1's in the array ğ•©.
#
#     Ix >âŸ¨âŸ¨1,0,1âŸ©,âŸ¨0,0,1âŸ©,âŸ¨0,0,1âŸ©âŸ©
# âŸ¨ âŸ¨ 0 0 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 1 2 âŸ© âŸ¨ 2 2 âŸ© âŸ©
#     Ix 4â‰¥ 3â€¿3â¥Šâ†•9
# âŸ¨ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ©
Ix â‡ /â—‹â¥ŠâŸœâ†•âŸœâ‰¢

# Combine hash-maps and apply ğ”½ to duplicate keys.
_merge â‡ { W _ğ•£ hms:
  c â† â€¢HashMapËœâŸ¨âŸ©
  { ğ•Šhm:
    { ğ•Škâ€¿v: c.Has k? k c.Set (v W c.Get k);
      ğ•Škâ€¿v: k c.Set v
    }Â¨ (hm.Keys@)â‹ˆÂ¨(hm.Values@)
  }Â¨hms
  c
}

tab â‡ @+9
lf  â‡ @+10
