inpâ†â€¢ParseFloatâŠ‘â€¢FLines"../inputs/day17.txt"

# Actually simulate the thing; since we're moving to the right, the list as a
# whole has to rotate to the *left*. Move one more than the input so we insert
# to the right. This also keeps the point of insertion at the very front of
# the list, so we don't need to keep track of the index.
â€¢Show 1âŠ‘{ğ•¨âˆ¾(inp+1)âŒ½â¥Šğ•©}Â´âŒ½â†•2018 # â‡’ 1487

# We don't actually need to simulate the whole thing to know where one number
# is inserted. The 0-based indices are determined by the formula
#
#    (strideÃ—index  mod  round) + 1
#                               ^^^ we are inserting after the index
#
# where 'index' is the current index, 'round' is the current round, and
# 'stride' is the stride length (i.e., our input). A simple scan over the
# (long!) input list gets us a (long!) list of all indices where things are
# at. We then just need to find the biggest index where a 1 is inserted, as we
# are looking for the largest (= also latest) item after 0.
â€¢Show âŠ‘50e6-1âŠËœâŒ½0{1+ğ•©|inp+ğ•¨}`1+â†•50e6 # â‡’ 25674054
