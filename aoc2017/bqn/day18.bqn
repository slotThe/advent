âŸ¨SplitâŸ©â†â€¢Import"../../util/bqn_util/util.bqn"
inp â† â€¢ParseFloatâŠâŠ¢Â¨âˆ˜(' 'âŠ¸Split)Â¨â€¢FLines "../inputs/day18.txt"

V â† { 1=â€¢Type ğ•©? ğ•©; (âŠ‘ğ•©-"a")âŠ‘ğ•¨ } # [V]alue, ğ•¨=arr, ğ•©=el
_C â† { regs F _ğ•£ xâ€¿y: FâŸœ(regs V y)âŒ¾((âŠ‘x-"a")âŠ¸âŠ‘) regs } # [C]hange

# Simulate the instructions taking two arguments;
# these are the same for both parts.
SD â† { ğ•ŠâŸ¨ix,regs,insâ€¿xâ€¿yâŸ©:
  { ğ•Š"set": âŸ¨ix+1, regs  âŠ¢_C xâ€¿yâŸ©;
    ğ•Š"add": âŸ¨ix+1, regs  +_C xâ€¿yâŸ©;
    ğ•Š"mul": âŸ¨ix+1, regs  Ã—_C xâ€¿yâŸ©;
    ğ•Š"mod": âŸ¨ix+1, regs |Ëœ_C xâ€¿yâŸ©;
    ğ•Š"jgz": 0<regs V x? âŸ¨ix+regs V y, regsâŸ©;
    ğ•Š"jgz": âŸ¨ix+1, regsâŸ©
  } ins
}

snd â† 0
One â† {
  ğ•ŠâŸ¨ix,regs,insâ€¿xâŸ©:
    { ğ•Š"snd": sndâ†©regs V x â‹„ âŸ¨ix+1, regsâŸ©;
      ğ•Š"rcv": snd!0=regs V x â‹„ âŸ¨ix+1, regsâŸ©
    } ins;
  SD ğ•©
}
{ğ•Šiâ€¿r: OneâŸ¨i,r,iâŠ‘inpâŸ©}â€¢_while_{ğ•Šiâ€¿Â·: (iâ‰¥0)âˆ§i<â‰ inp}âŠâ€¢CurrentErrorâŸ¨0,16â¥Š0âŸ© # â‡’ 9423

Two â† { # my queue, other queue, index, registers, instruction
  ğ•ŠâŸ¨my,ot,ix,rs,"snd"â€¿xâŸ©: otâˆ¾â†©rs V x â‹„ âŸ¨my, ot, ix+1, rsâŸ©;
  ğ•ŠâŸ¨âŸ¨âŸ©,ot,ix,rs,"rcv"â€¿xâŸ©: âŸ¨âŸ¨âŸ©,ot,ix,rsâŸ©;
  ğ•ŠâŸ¨my,ot,ix,rs,"rcv"â€¿xâŸ©: qâ€¿qs â† 1(â†‘â‹ˆâ†“)my â‹„ âŸ¨qs, ot, ix+1, rsâŠ¢_CâŸ¨x,âŠ‘qâŸ©âŸ©;
  ğ•ŠâŸ¨my,ot,ix,rs,insâŸ©    : âŸ¨my,otâŸ©âˆ¾SDâŸ¨ix,rs,insâŸ©
}

# Concurrency at home:
âŠ‘{ ğ•Šs1â€¿q0â€¿q1â€¿i1â€¿r1â€¿i2â€¿r2â€¿xs: # hahahahahahahahaha
  âŸ¨q0,q1,i1,r1âŸ© â†© TwoâŸ¨q0,q1,i1,r1,i1âŠ‘xsâŸ©
  old0 â† â‰ q0
  âŸ¨q1,q0,i2,r2âŸ© â†© TwoâŸ¨q1,q0,i2,r2,i2âŠ‘xsâŸ© # q0 and q1 swap here
  âŸ¨s1+old0<â‰ q0,q0,q1,i1,r1,i2,r2,xsâŸ©
}â€¢_while_{ ğ•ŠÂ·â€¿q0â€¿q1â€¿i1â€¿Â·â€¿i2â€¿Â·â€¿xs:
  âˆ¨Â´âŸ¨ q0â‰¢âŸ¨âŸ©, q1â‰¢âŸ¨âŸ©, "rcv"â‰¢âŠ‘i1âŠ‘xs, "rcv"â‰¢âŠ‘i2âŠ‘xs âŸ©
} âŸ¨0, âŸ¨âŸ©,âŸ¨âŸ©, 0,(15â¥Š0)âˆ¾0, 0,(15â¥Š0)âˆ¾1, inpâŸ© # â‡’ 7620
