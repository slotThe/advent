inp â† â€¢ParseFloat âŠ‘ â€¢FLines "../inputs/day03.txt"

# The pattern goes a bit like this:
#
#     R U 2L 2D 3R 3U 4L 4D 5R 5Uâ€¦
Coords â† { # 2Ã—ğ•©: Number of steps to go.
  dirs â† (2Ã—ğ•©)â¥ŠâŸ¨0â€¿1, 1â€¿0, 0â€¿Â¯1, Â¯1â€¿0âŸ© # r u l d
  natnat â† âˆ¾(â†•â‹ˆÂ¨â†•)ğ•©                   # 0 0 1 1 2 2 3 3 â€¦
  +`âˆ¾natnat{<Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨dirs             # expand
}
+Â´| (inp-2) âŠ‘ Coords 1000 # â‡’ 552

# This is not an array algorithm in the slightest; sorry. It's what one would
# normally do: create a new grid, look for all neighbours, and then just add
# the values together. C'est la vie.

N â† { xâ€¿y: â¥Š(x+âŸ¨Â¯1, 0, 1âŸ©)â‹ˆâŒœ(y+âŸ¨Â¯1, 0, 1âŸ©) }
Sim â† { # ğ•¨ = grid = (xâ€¿y)â†’n, â€¦; ğ•© = coords = âŸ¨xâ€¿y, â€¦âŸ©
  (Â¯1âŠ‘ğ•¨.Values@)>inp?           # Newest value larger than input?
    Â¯1âŠ‘ğ•¨.Values@;
  grid ğ•Š coords:
    pâ€¿cs â† 1(â†‘â‹ˆâ†“)coords â‹„ pâŠ‘â†©   # Point and rest
    p grid.Set +Â´0âŠ¸grid.GetÂ¨N p # Get neighbour sums and set for point
    grid ğ•Š cs                   # Recurse
}
â€¢Show {hâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ© â‹„ 0â€¿0 h.Set 1 â‹„ h} Sim Coords 10 # â‡’ 330785
