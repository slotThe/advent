inp â† â€¢ParseFloat âŠ‘ â€¢FLines "../inputs/day03.txt"

# The pattern goes a bit like this:
#
#     R U 2L 2D 3R 3U 4L 4D 5R 5Uâ€¦
Coords â† {
  dirs â† (2-Ëœ2Ã—ğ•©)â¥ŠâŸ¨0â€¿1, 1â€¿0, 0â€¿Â¯1, Â¯1â€¿0âŸ© # r u l d
  natnat â† âˆ¾1â†“(â†•â‹ˆÂ¨â†•)ğ•© # 1 1 2 2 3 3 â€¦
  âŸ¨0â€¿0âŸ©âˆ¾ +` âˆ¾ natnat{â¥Šâ‹ˆË˜ âˆ˜â€¿2â¥Š Â¯1â†“ ğ•©âˆ¾âŸâŠ¢ğ•¨}Â¨dirs # expand
}
â€¢Show +Â´| (inp-1) âŠ‘ Coords 1000 # magic number

# This is not an array algorithm in the slightest; sorry. It's what one would
# normally do: create a new grid, look for all neighbours, and then just add
# the values together. Without maps this is pretty inefficient, of course, but
# c'est la vie.
Neighbours â† { xâ€¿y:
  n â† âŸ¨Â¯1, 0, 1âŸ©
  â¥Š(x+n)â‹ˆâŒœ(y+n)
}

Two â† {
  grid ğ•Š c:
    val â† 1âŠ‘âŠ‘grid # newest value
    val>inp? val;
  grid ğ•Š coords:   # grid = âŸ¨(xâ€¿y)â€¿n, â€¦âŸ©, coords = âŸ¨xâ€¿y, â€¦âŸ©
    pâ€¿cs â† 1(â†‘â‹ˆâ†“)coords â‹„ p â†© âŠ‘p # point and rest
    n â† +Â´ 1âŠ‘Â¨ âˆ¾ {grid/Ëœ (ğ•©âŠ¸â‰¡âŠ‘)Â¨grid}Â¨ Neighbours p
    (âŸ¨pâ€¿nâŸ©âˆ¾grid)ğ•Šcs
}
â€¢Show âŸ¨(0â€¿0)â€¿1âŸ© Two 1â†“(Coords 10) # magic number
